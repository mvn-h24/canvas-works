<!doctype html>
<meta charset="utf-8" />
<title>D3 + Canvas: High-density Line (Downsampling + Interpolation Selector)</title>
<style>
  :root { color-scheme: light dark; }
  body { margin: 0; font: 13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  #wrap { width: 100%; max-width: 1000px; margin: 24px auto; padding: 0 12px; }
  .chart { position: relative; user-select: none; }
  .axis path, .axis line { shape-rendering: crispEdges; }
  .hud { display: flex; gap: 12px; align-items: center; margin-bottom: 8px; flex-wrap: wrap; }
  .hud label { display: inline-flex; gap: 6px; align-items: center; }
  .legend { opacity: .7; }
  input[type="number"] { width: 10ch; }
  button { padding: 4px 10px; }
  .hidden { display: none; }
</style>

<div id="wrap">
  <div class="hud">
    <label><input id="autoY" type="checkbox" checked /> авто-масштаб Y при зуме</label>
    <label><input id="useDS" type="checkbox" checked /> даунсемплинг</label>
    <label class="rate">агрессивность: <input id="dsRate" type="range" min="1" max="16" step="1" value="1" /> <b id="dsRateLabel">1px/бин</b></label>

    <label><input id="useInterp" type="checkbox" /> интерполяция</label>
    <label>тип:
      <select id="curveSelect" disabled>
        <option value="catmullRom">Catmull–Rom</option>
        <option value="monotoneX">Monotone X</option>
        <option value="natural">Natural</option>
        <option value="basis">Basis</option>
        <option value="cardinal">Cardinal</option>
        <option value="bundle">Bundle</option>
        <option value="bumpX">Bump X</option>
        <option value="step">Step</option>
        <option value="stepBefore">Step Before</option>
        <option value="stepAfter">Step After</option>
        <option value="linear">Linear</option>
      </select>
    </label>

    <label id="alphaWrap" class="hidden">α: <input id="alphaSlider" type="range" min="0" max="1" step="0.05" value="0.5" /> <b id="alphaLabel">0.50</b></label>
    <label id="tensionWrap" class="hidden">τ: <input id="tensionSlider" type="range" min="0" max="1" step="0.05" value="0.00" /> <b id="tensionLabel">0.00</b></label>
    <label id="betaWrap" class="hidden">β: <input id="betaSlider" type="range" min="0" max="1" step="0.05" value="0.85" /> <b id="betaLabel">0.85</b></label>

    <label>точек: <input id="nInput" type="number" min="1000" max="5000000" step="10000" value="500000" /></label>
    <button id="regen">Перегенерировать</button>
    <span class="legend">кол-во точек: <b id="count">—</b> · отображается: <b id="visible">—</b></span>
  </div>
  <div id="chart" class="chart"></div>
</div>

<script type="module">
  import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

  // ==== Конфиг ====
  const SIZE = { width: 960, height: 420 };
  const MARGIN = { top: 16, right: 20, bottom: 28, left: 48 };
  const AUTO_RESCALE_Y = true;           // по умолчанию включено
  const DEFAULT_USE_DS = true;           // даунсемплинг включен
  const DEFAULT_USE_INTERP = false;      // интерполяция выключена
  const DEFAULT_CURVE = 'catmullRom';    // дефолт (когда включишь интерполяцию)
  const LINE_WIDTH = 1;
  const LINE_COLOR = "#2474ff";
  const BG_COLOR = getComputedStyle(document.body).backgroundColor || "#fff";
  const MAX_POINTS = 5_000_000;

  // ==== Базовая сцена ====
  const dpi = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const width = SIZE.width;
  const height = SIZE.height;

  const chart = d3.select("#chart")
    .style("width", `${width}px`)
    .style("height", `${height}px`);

  const canvas = chart.append("canvas")
    .attr("width", width * dpi)
    .attr("height", height * dpi)
    .style("width", `${width}px`)
    .style("height", `${height}px`)
    .node();

  const ctx = canvas.getContext("2d", { desynchronized: true });
  ctx.scale(dpi, dpi);

  // SVG поверх — только для осей и захвата событий зума
  const svg = chart.append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("position", "absolute")
    .style("inset", 0);

  // ==== Шкалы ====
  const x = d3.scaleLinear().range([MARGIN.left, width - MARGIN.right]);
  const y = d3.scaleLinear().range([height - MARGIN.bottom, MARGIN.top]);

  const x0 = x.copy();
  const y0 = y.copy();

  // ==== Оси ====
  const gx = svg.append("g").attr("class", "axis x").attr("transform", `translate(0,${height - MARGIN.bottom})`);
  const gy = svg.append("g").attr("class", "axis y").attr("transform", `translate(${MARGIN.left},0)`);

  function drawAxes() {
    gx.call(d3.axisBottom(x).ticks(Math.floor(width / 80)));
    gy.call(d3.axisLeft(y).ticks(Math.floor(height / 50)));
  }

  // ==== Демо-данные ====
  function generateData(n) {
    const out = new Array(n);
    let yv = 0;
    for (let i = 0; i < n; i++) {
      yv += Math.sin(i * 0.015) * 0.3 + (Math.random() - 0.5) * 0.2;
      out[i] = { x: i, y: yv };
    }
    return out;
  }

  let data = [];
  const nInput = document.getElementById("nInput");
  const regenBtn = document.getElementById("regen");
  const countEl = d3.select("#count");
  const visibleEl = d3.select("#visible");

  function clamp(n, min, max) { return Math.min(max, Math.max(min, n)); }

  function setData(n) {
    const N = clamp(parseInt(n, 10) || 0, +nInput.min, MAX_POINTS);
    nInput.value = String(N);

    data = generateData(N);
    countEl.text(N.toLocaleString("en-US"));

    x.domain(d3.extent(data, d => d.x));
    x0.domain(x.domain());

    const yDom = d3.extent(data, d => d.y);
    if (yDom[0] === yDom[1]) {
      const eps = Math.abs(yDom[0] || 1) * 1e-6;
      yDom[0] -= eps; yDom[1] += eps;
    }
    y.domain(yDom).nice();
    y0.domain(y.domain());

    overlay.call(zoom.transform, d3.zoomIdentity);

    drawAxes();
    scheduleRender();
  }

  // ==== Децимация: min/max на колонку пикселя ====
  function decimateMinMaxPerPixel(src, xScale, binPx = 1, accessorX = d => d.x, accessorY = d => d.y) {
    const leftPx = MARGIN.left;
    const rightPx = width - MARGIN.right;
    const innerWidth = rightPx - leftPx;
    if (innerWidth <= 0) return src;

    const [xStart, xEnd] = xScale.domain();
    const domainSpan = xEnd - xStart;
    if (domainSpan === 0) return src;

    const binsCount = Math.max(1, Math.floor(innerWidth / Math.max(1, binPx)));

    // Предварительное ограничение итерации только видимым диапазоном
    let i0 = 0, i1 = src.length - 1;
    if (src.length >= 2 && typeof accessorX(src[0]) === "number" && accessorX(src[src.length - 1]) - accessorX(src[0]) + 1 === src.length) {
      const base = accessorX(src[0]);
      i0 = Math.max(0, Math.floor(xStart - base));
      i1 = Math.min(src.length - 1, Math.ceil(xEnd - base));
    }

    const binsMin = new Array(binsCount);
    const binsMax = new Array(binsCount);

    for (let i = i0; i <= i1; i++) {
      const d = src[i];
      const vx = accessorX(d);
      if (vx < xStart || vx > xEnd) continue;
      const pos = (vx - xStart) / domainSpan * (innerWidth - 1);
      const b = Math.min(binsCount - 1, Math.max(0, Math.floor(pos / Math.max(1, binPx))));
      const vy = accessorY(d);

      const bmin = binsMin[b];
      if (!bmin || vy < bmin.vy) binsMin[b] = { d, vy };

      const bmax = binsMax[b];
      if (!bmax || vy > bmax.vy) binsMax[b] = { d, vy };
    }

    const result = [];
    for (let b = 0; b < binsCount; b++) {
      const mn = binsMin[b];
      const mx = binsMax[b];
      if (!mn && !mx) continue;
      if (!mn || !mx || mn.d === mx.d) {
        result.push((mn || mx).d);
      } else {
        result.push(mn.d, mx.d);
      }
    }
    return result.length ? result : src;
  }

  // ==== Линия через d3-shape с Canvas контекстом ====
  const lineGen = d3.line()
    .x(d => x(d.x))
    .y(d => y(d.y))
    .context(ctx);

  function clearCanvas() {
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (BG_COLOR) {
      ctx.fillStyle = BG_COLOR;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    ctx.restore();
  }

  function drawLine(points) {
    if (!points.length) return;
    ctx.beginPath();
    lineGen(points);
    ctx.lineWidth = LINE_WIDTH;
    ctx.strokeStyle = LINE_COLOR;
    ctx.stroke();
  }

  function computeVisibleYDomain(points) {
    if (!points.length) return y.domain();
    let ymin = +Infinity, ymax = -Infinity;
    for (let i = 0; i < points.length; i++) {
      const v = points[i].y;
      if (v < ymin) ymin = v;
      if (v > ymax) ymax = v;
    }
    if (ymin === ymax) {
      const eps = Math.abs(ymin || 1) * 1e-6;
      ymin -= eps; ymax += eps;
    }
    return [ymin, ymax];
  }

  // RAF-батчинг
  let raf = 0;
  function scheduleRender() {
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(render);
  }

  // ==== UI элементы ====
  const autoY = document.getElementById("autoY");
  autoY.checked = AUTO_RESCALE_Y;
  autoY.addEventListener("change", scheduleRender);

  const useDS = document.getElementById("useDS");
  useDS.checked = DEFAULT_USE_DS;

  const dsRate = document.getElementById("dsRate");
  const dsRateLabel = document.getElementById("dsRateLabel");
  function updateRateLabel() { dsRateLabel.textContent = `${dsRate.value}px/бин`; }
  updateRateLabel();

  useDS.addEventListener("change", () => { dsRate.disabled = !useDS.checked; scheduleRender(); });
  dsRate.addEventListener("input", () => { updateRateLabel(); scheduleRender(); });
  dsRate.disabled = !useDS.checked;

  const useInterp = document.getElementById("useInterp");
  useInterp.checked = DEFAULT_USE_INTERP;

  const curveSelect = document.getElementById("curveSelect");
  curveSelect.value = DEFAULT_CURVE;

  const alphaWrap = document.getElementById("alphaWrap");
  const tensionWrap = document.getElementById("tensionWrap");
  const betaWrap = document.getElementById("betaWrap");

  const alphaSlider = document.getElementById("alphaSlider");
  const alphaLabel = document.getElementById("alphaLabel");
  const tensionSlider = document.getElementById("tensionSlider");
  const tensionLabel = document.getElementById("tensionLabel");
  const betaSlider = document.getElementById("betaSlider");
  const betaLabel = document.getElementById("betaLabel");

  function fmt2(v) { return (+v).toFixed(2); }

  function updateInterpControlsState() {
    const enabled = useInterp.checked;
    curveSelect.disabled = !enabled;
    // показываем/скрываем слайдеры по выбранной кривой
    const sel = curveSelect.value;
    alphaWrap.classList.toggle('hidden', !(enabled && sel === 'catmullRom'));
    tensionWrap.classList.toggle('hidden', !(enabled && sel === 'cardinal'));
    betaWrap.classList.toggle('hidden', !(enabled && sel === 'bundle'));
  }

  function updateParamLabels() {
    alphaLabel.textContent = fmt2(alphaSlider.value);
    tensionLabel.textContent = fmt2(tensionSlider.value);
    betaLabel.textContent = fmt2(betaSlider.value);
  }

  function getSelectedCurve() {
    const sel = curveSelect.value;
    switch (sel) {
      case 'catmullRom': return d3.curveCatmullRom.alpha(parseFloat(alphaSlider.value) || 0.5);
      case 'cardinal':  return d3.curveCardinal.tension(parseFloat(tensionSlider.value) || 0);
      case 'bundle':    return d3.curveBundle.beta(parseFloat(betaSlider.value) || 0.85);
      case 'monotoneX': return d3.curveMonotoneX;
      case 'natural':   return d3.curveNatural;
      case 'basis':     return d3.curveBasis;
      case 'bumpX':     return d3.curveBumpX;
      case 'step':      return d3.curveStep;
      case 'stepBefore':return d3.curveStepBefore;
      case 'stepAfter': return d3.curveStepAfter;
      case 'linear':
      default:          return d3.curveLinear;
    }
  }

  function applyCurve() {
    if (useInterp.checked) {
      lineGen.curve(getSelectedCurve());
    } else {
      lineGen.curve(d3.curveLinear);
    }
  }

  // первичная инициализация UI
  updateParamLabels();
  updateInterpControlsState();
  applyCurve();

  useInterp.addEventListener('change', () => { updateInterpControlsState(); applyCurve(); scheduleRender(); });
  curveSelect.addEventListener('change', () => { updateInterpControlsState(); applyCurve(); scheduleRender(); });
  alphaSlider.addEventListener('input', () => { updateParamLabels(); applyCurve(); scheduleRender(); });
  tensionSlider.addEventListener('input', () => { updateParamLabels(); applyCurve(); scheduleRender(); });
  betaSlider.addEventListener('input', () => { updateParamLabels(); applyCurve(); scheduleRender(); });

  // ==== Рендер ====
  function render() {
    clearCanvas();

    let points;
    if (useDS.checked) {
      points = decimateMinMaxPerPixel(
        data,
        x,
        Math.max(1, parseInt(dsRate.value, 10) || 1)
      );
    } else {
      const [xStart, xEnd] = x.domain();
      points = data.filter(d => d.x >= xStart && d.x <= xEnd);
    }

    if (autoY.checked) {
      y.domain(computeVisibleYDomain(points)).nice();
    } else {
      y.domain(y0.domain());
    }

    drawAxes();
    visibleEl.text(points.length.toLocaleString("en-US"));
    drawLine(points);
  }

  // ==== Зум/пан ====
  const zoom = d3.zoom()
    .scaleExtent([1, 10_000])
    .translateExtent([[MARGIN.left, MARGIN.top], [width - MARGIN.right, height - MARGIN.bottom]])
    .on("zoom", (ev) => {
      const t = ev.transform;
      const zx = t.rescaleX(x0);
      x.domain(zx.domain());
      scheduleRender();
    });

  const overlay = svg.append("rect")
    .attr("x", MARGIN.left)
    .attr("y", MARGIN.top)
    .attr("width", width - MARGIN.left - MARGIN.right)
    .attr("height", height - MARGIN.top - MARGIN.bottom)
    .style("fill", "transparent")
    .style("cursor", "grab")
    .call(zoom);

  // ==== Инициализация ====
  setData(nInput.value);
  regenBtn.addEventListener("click", () => setData(nInput.value));
  nInput.addEventListener("keydown", (e) => { if (e.key === "Enter") setData(nInput.value); });

  drawAxes();
  render();
</script>
