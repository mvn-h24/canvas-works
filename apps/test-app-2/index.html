<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Шкала времени</title>

    <style>
      :root {
        --bg: #0d0f12;
        --panel: #171a1f;
        --fg: #eef2ff;
        --muted: #9aa4b2;
        --grid: #2a2f39;
        --accent: #7aa2ff;
        --accent-2: #52d3a8;
        --block-odd: #12151a;
        --block-even: #0f1318;
        --tag-bg: #212633;
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      /* Controls */
      #controls {
        display: grid;
        grid-template-columns: auto auto 1fr auto auto;
        gap: 12px 16px;
        align-items: center;
        margin: 12px;
        background: var(--panel);
        padding: 12px 16px;
        border-radius: 12px;
        line-height: 1.2;
      }
      #controls label { color: var(--fg); }
      #controls select, #controls button, #controls input[type="checkbox"] {
        accent-color: var(--accent);
      }
      #controls select, #controls button {
        background: #1f2430;
        color: var(--fg);
        border: 1px solid #273042;
        border-radius: 10px;
        padding: 8px 12px;
      }
      #controls button:hover { filter: brightness(1.08); }
      #stepDisplay, #rangeDisplay, #hint {
        font-size: 12px; color: var(--muted); opacity: .95;
      }
      #hint { grid-column: 1/-1; }

      /* Container */
      #container {
        flex: 1;
        width: 100%;
        overflow-y: auto;
        position: relative;
        border-top: 1px solid #1a2030;
        scroll-behavior: auto;
      }

      /* SVG */
      svg { width: 100%; display: block; }

      .tick text {
        fill: #d8def0;
        font-size: 12px;
        text-anchor: start;
      }
      .tick line { stroke: var(--grid); }

      .now-line { stroke: var(--accent); stroke-width: 1.5; stroke-dasharray: 4 4; }
      .now-label { fill: var(--accent); font-size: 12px; font-weight: 600; }

      .block-bg { fill-opacity: 0.9; }
      .block-label {
        font-size: 11px;
        fill: var(--muted);
      }

      .tag {
        position: sticky;
        top: 8px;
        left: 0;
        display: inline-flex;
        gap: 6px;
        align-items: center;
        background: var(--tag-bg);
        border: 1px solid #2a3446;
        border-radius: 999px;
        padding: 6px 10px;
        margin-left: 12px;
        color: var(--fg);
        font-size: 12px;
        z-index: 5;
      }
      .dot { width: 8px; height: 8px; border-radius: 999px; background: var(--accent-2); display: inline-block; }

      .event {
        fill: var(--accent-2);
        stroke: #0b1613;
        stroke-width: 1;
      }
      .event-label {
        fill: #c9ffeb;
        font-size: 11px;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <label>Масштаб блока:
        <select id="scale">
          <option value="5">5 минут</option>
          <option value="10">10 минут</option>
          <option value="30" selected>30 минут</option>
          <option value="60">1 час</option>
          <option value="120">2 часа</option>
        </select>
      </label>

      <label style="display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="live" checked />
        Живой режим
      </label>

      <div id="stepDisplay">Шаг: —</div>
      <div id="rangeDisplay">Диапазон: —</div>

      <div style="text-align:right">
        <button id="jumpNow">К текущему времени</button>
      </div>

      <div id="hint">Ctrl + колесо — плавный зум, клавиши + / − — изменить масштаб. «Живой режим» — авто‑сдвиг индикатора «Сейчас». В URL: <code>?freezeNow=2025-04-20T00:00:00</code> — зафиксировать «сейчас», <code>&scale=30</code> — стартовый масштаб, <code>&demo=1</code> — показать события.</div>
    </div>

    <div class="tag"><span class="dot"></span><span id="nowTag">Сейчас: —</span></div>

    <div id="container">
      <svg id="chart" preserveAspectRatio="xMinYMin meet" aria-label="Вертикальная шкала времени"></svg>
    </div>

    <script type="module">
      import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';

        // ---------- URL параметры ----------
      const url = new URL(location.href);
      const freezeNowParam = url.searchParams.get('freezeNow');
      const initialScaleParam = url.searchParams.get('scale');
      const demoEventsParam = url.searchParams.get('demo') === '1';

      // ---------- DOM ----------
      const svg = d3.select('#chart');
      const container = document.getElementById('container');
      const select = document.getElementById('scale');
      const liveToggle = document.getElementById('live');
      const stepDisplay = document.getElementById('stepDisplay');
      const rangeDisplay = document.getElementById('rangeDisplay');
      const jumpNowBtn = document.getElementById('jumpNow');
      const nowTag = document.getElementById('nowTag');

      // ---------- Состояние ----------
      let customScale = null;           // пользовательский масштаб (мин)
      let initialized = false;          // первый рендер?
      let liveTimer = null;             // таймер «живого» обновления
      let liveEveryMs = null;           // частота перерендера
      let frozenNow = freezeNowParam ? new Date(freezeNowParam) : null;

      // Реал-тайм: фиксируем старт шкалы и динамически её продлеваем
      const baselineBlocks = 3;         // как и раньше — 3 блока по умолчанию
      let timelineStart = frozenNow ?? new Date();  // якорь шкалы (в прошлой версии он был «сейчас»)
      let extraForwardSteps = 5;        // (1) продлеваем шкалу вперёд на 5 шагов

      if (initialScaleParam) {
        const num = +initialScaleParam;
        if (!Number.isNaN(num) && num > 0) {
          customScale = num;
          ensureCustomOption();
          select.value = String(num);
        }
      }

      // ---------- Утилиты ----------
      function getNow() {
        return frozenNow ?? new Date();
      }

      function formatDateTime(dt) {
        const pad = (n) => String(n).padStart(2, '0');
        const dd = pad(dt.getDate());
        const mm = pad(dt.getMonth() + 1);
        const yyyy = dt.getFullYear();
        const HH = pad(dt.getHours());
        const MM = pad(dt.getMinutes());
        const SS = pad(dt.getSeconds());
        return `${dd}.${mm}.${yyyy} ${HH}:${MM}:${SS}`;
      }

      // Тики строго по шагу
      function generateTicks(startMs, endMs, stepMs) {
        stepMs = Math.max(1, Math.round(stepMs));
        const ticks = [];
        const count = Math.floor((endMs - startMs) / stepMs);
        for (let i = 0; i <= count; i++) {
          ticks.push(new Date(startMs + i * stepMs));
          if (ticks.length > 8000) break; // предохранитель
        }
        return ticks;
      }

      function chooseTickFormat(stepMs) {
        if (stepMs >= 60 * 60 * 1000) return d3.timeFormat('%d.%m.%Y %H:%M'); // >= 1h
        if (stepMs >= 60 * 1000) return d3.timeFormat('%d.%m.%Y %H:%M');      // >= 1min
        return d3.timeFormat('%d.%m.%Y %H:%M:%S');                             // < 1min
      }

      function ensureCustomOption() {
        if (customScale !== null) {
          let customOption = select.querySelector('option[data-custom="1"]');
          if (!customOption) {
            customOption = document.createElement('option');
            customOption.dataset.custom = '1';
            select.appendChild(customOption);
          }
          customOption.value = String(customScale);
          customOption.textContent = `Пользовательский (${customScale.toFixed(0)} мин)`;
          select.value = customOption.value;
        }
      }

      function removeCustomOption() {
        const customOption = select.querySelector('option[data-custom="1"]');
        if (customOption) customOption.remove();
      }

      function updateStickyNowTag(now) {
        nowTag.textContent = `Сейчас: ${formatDateTime(now)} (${Intl.DateTimeFormat().resolvedOptions().timeZone})`;
      }

      function blockLabelText(i, start, end, totalBlocks) {
        const f = d3.timeFormat('%d.%m.%Y %H:%M');
        return `Блок ${i + 1}/${totalBlocks} · ${f(start)} — ${f(end)}`;
      }

      // Контроль живого режима (перерисовка и автопродление)
      function ensureLiveTimer(stepMs) {
        if (!liveToggle.checked) {
          if (liveTimer) clearInterval(liveTimer);
          liveTimer = null;
          liveEveryMs = null;
          return;
        }
        // По-умолчанию чаще, чтобы индикатор «Сейчас» плавно двигался
        const desired = stepMs >= 60_000 ? 2_000 : 1_000;
        if (liveEveryMs !== desired) {
          if (liveTimer) clearInterval(liveTimer);
          liveTimer = setInterval(() => render({ preserveScroll: true }), desired);
          liveEveryMs = desired;
        }
      }

      // ---------- Демо события (опционально) ----------
      function getDemoEvents(start, end) {
        if (!demoEventsParam) return [];
        const events = [];
        const totalMs = end - start;
        for (let i = 1; i <= 6; i++) {
          const t = +start + (totalMs * i) / 7;
          events.push({ time: new Date(t), label: `Событие #${i}` });
        }
        return events;
      }

      // ---------- Рендер ----------
      function render({ preserveScroll = false } = {}) {
        svg.selectAll('*').remove();

        const now = getNow();
        updateStickyNowTag(now);

        const scaleMinutes = customScale ?? +select.value; // масштаб одного блока (мин)
        const viewportHeight = container.clientHeight || 400;
        const blockMs = scaleMinutes * 60 * 1000;
        const stepMs = blockMs / 10; // делим блок на 10 равных делений

        // (2) Двигаем индикатор «Сейчас»: оставляем якорь в прошлом, индикатор растёт вниз по шкале
        // (3) Если до конца шкалы меньше двух делений — добавляем ещё 5 шагов
        const nowMs = +now;
        const startMs = +timelineStart;

        // Гарантируем, что старт не уедет в будущее из‑за freezeNow
        if (nowMs < startMs) timelineStart = new Date(nowMs);

        // Убедимся, что всегда есть запас вперёд минимум на extraForwardSteps
        function computeEndMs() {
          return startMs + baselineBlocks * blockMs + extraForwardSteps * stepMs;
        }

        let endMs = computeEndMs();
        // Если «сейчас» подходит к концу (<= 2 шага до конца), докидываем +5 шагов.
        while ((endMs - nowMs) / stepMs <= 2) {
          extraForwardSteps += 5; // (1) и (3)
          endMs = computeEndMs();
        }

        const endDate = new Date(endMs);

        // Сколько «блоков» помещается в текущую длину шкалы (может быть дробным)
        const blocksFloat = (endMs - startMs) / blockMs;
        const fullBlocks = Math.floor(blocksFloat);

        // Высота SVG пропорциональна количеству «блоков»
        const svgHeight = Math.max(1, blocksFloat * (container.clientHeight || 400));
        svg.attr('width', container.clientWidth)
          .attr('height', svgHeight)
          .style('height', svgHeight + 'px');

        const y = d3.scaleTime()
          .domain([new Date(startMs), endDate])
          .range([0, svgHeight]);

        // Подготовка оси и тиков
        const ticks = generateTicks(startMs, endMs, stepMs);
        const format = chooseTickFormat(stepMs);

        const leftPadding = 12;
        const rightPadding = 12;
        const innerWidth = Math.max(0, container.clientWidth - leftPadding - rightPadding);

        // Фон блоков (в т.ч. частично последний)
        const gBg = svg.append('g');
        const totalBlocks = Math.ceil(blocksFloat);
        for (let i = 0; i < totalBlocks; i++) {
          const blockStart = new Date(startMs + i * blockMs);
          const blockEndMs = Math.min(startMs + (i + 1) * blockMs, endMs);
          const blockEnd = new Date(blockEndMs);
          const y1 = y(blockStart);
          const y2 = y(blockEnd);
          gBg.append('rect')
            .attr('x', 0)
            .attr('y', y1)
            .attr('width', container.clientWidth)
            .attr('height', Math.max(0, y2 - y1))
            .attr('class', 'block-bg')
            .attr('fill', i % 2 === 0 ? 'var(--block-odd)' : 'var(--block-even)');
          gBg.append('text')
            .attr('x', leftPadding + 4)
            .attr('y', y1 + 14)
            .attr('class', 'block-label')
            .text(blockLabelText(i, blockStart, blockEnd, totalBlocks));
        }

        // Ось
        const axis = d3.axisLeft(y)
          .tickValues(ticks)
          .tickSize(-innerWidth)
          .tickPadding(8)
          .tickFormat(format);

        const g = svg.append('g')
          .attr('transform', `translate(${leftPadding}, 0)`)
          .call(axis);

        g.selectAll('.domain').remove();
        g.selectAll('.tick text').attr('dy', '0.9em').attr('fill', '#d8def0');
        g.selectAll('.tick line').attr('stroke', '#2a2f39').attr('stroke-opacity', 0.6);

        // Подсветка границ блоков и половины
        g.selectAll('.tick').each(function(d) {
          const ms = +d - startMs;
          const isBoundary = (ms % blockMs) === 0;
          const isHalf = (ms % (blockMs / 2)) === 0;
          d3.select(this).select('line')
            .attr('stroke-width', isBoundary ? 2 : isHalf ? 1.5 : 1)
            .attr('stroke-opacity', isBoundary ? 0.9 : isHalf ? 0.75 : 0.6);
          d3.select(this).select('text')
            .attr('font-weight', isBoundary ? 700 : 400);
        });

        // Чуть поджать подпись последнего тика
        const nodes = g.selectAll('.tick').nodes();
        if (nodes.length > 0) {
          d3.select(nodes[nodes.length - 1]).select('text').attr('dy', '-0.3em');
        }

        // Линия «Сейчас» — теперь по шкале, а не всегда сверху
        const yNow = Math.max(0, Math.min(svgHeight, y(now)));
        svg.append('line')
          .attr('x1', 0)
          .attr('x2', container.clientWidth)
          .attr('y1', yNow)
          .attr('y2', yNow)
          .attr('class', 'now-line');
        svg.append('text')
          .attr('x', leftPadding + 4)
          .attr('y', yNow - 6)
          .attr('class', 'now-label')
          .text('Сейчас');

        // Демо события
        const demoEvents = getDemoEvents(new Date(startMs), endDate);
        if (demoEvents.length) {
          const gEv = svg.append('g');
          demoEvents.forEach(ev => {
            const yEv = y(ev.time);
            gEv.append('circle').attr('class', 'event').attr('cx', container.clientWidth - 14).attr('cy', yEv).attr('r', 4);
            gEv.append('text').attr('class', 'event-label').attr('x', container.clientWidth - 18).attr('y', yEv - 6).attr('text-anchor', 'end').text(ev.label);
          });
        }

        // Инфо‑лейблы шага и диапазона
        const stepText = (stepMs >= 60000)
          ? (Math.round(stepMs / 60000 * 100) / 100).toFixed((stepMs % 60000 === 0) ? 0 : 2).replace(/\.00$/, '') + ' мин.'
          : Math.round(stepMs / 1000) + ' сек.';
        stepDisplay.textContent = `Шаг: ${stepText}`;
        rangeDisplay.textContent = `Диапазон: ${formatDateTime(new Date(startMs))} — ${formatDateTime(endDate)}`;

        // Управление прокруткой
        if (!preserveScroll) {
          if (!initialized) {
            container.scrollTop = Math.max(0, yNow - 24); // показать «Сейчас» на первом рендере
            initialized = true;
          }
        }

        // Живой режим
        ensureLiveTimer(stepMs);
      }

      // ---------- Слушатели ----------
      select.addEventListener('change', () => {
        const opt = select.options[select.selectedIndex];
        if (opt && opt.dataset && opt.dataset.custom === '1') {
          customScale = +opt.value;
        } else {
          customScale = null;
          removeCustomOption();
        }
        render({ preserveScroll: true });
      });

      liveToggle.addEventListener('change', () => {
        render({ preserveScroll: true });
      });

      // Масштабирование Ctrl + колесо (пользовательский масштаб в минутах)
      container.addEventListener('wheel', (event) => {
        if (event.ctrlKey) {
          event.preventDefault();
          let current = customScale ?? +select.value;
          current = event.deltaY < 0 ? Math.max(1, current - 1) : current + 1;
          customScale = current;
          ensureCustomOption();
          render({ preserveScroll: true });
        }
      }, { passive: false });

      // Горячие клавиши +/−
      window.addEventListener('keydown', (e) => {
        if (e.key === '+' || e.key === '=') {
          customScale = Math.max(1, (customScale ?? +select.value) - 1);
        } else if (e.key === '-' || e.key === '_') {
          customScale = (customScale ?? +select.value) + 1;
        } else {
          return;
        }
        e.preventDefault();
        ensureCustomOption();
        render({ preserveScroll: true });
      });

      // К текущему времени
      jumpNowBtn.addEventListener('click', () => {
        const now = getNow();
        const scaleMinutes = customScale ?? +select.value;
        const blockMs = scaleMinutes * 60 * 1000;
        const stepMs = blockMs / 10;
        const yScale = d3.scaleTime()
          .domain([timelineStart, new Date(+timelineStart + baselineBlocks * blockMs + extraForwardSteps * stepMs)])
          .range([0, (container.clientHeight || 400) * ((baselineBlocks * blockMs + extraForwardSteps * stepMs) / blockMs)]);
        const yNow = yScale(now);
        container.scrollTop = Math.max(0, yNow - 24);
      });

      // Адаптивный ререндер при изменении размеров
      const ro = new ResizeObserver(() => render({ preserveScroll: true }));
      ro.observe(container);

      // Первый рендер
      render();
    </script>
  </body>
</html>
