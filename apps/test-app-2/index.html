<!doctype html>
<meta charset="utf-8" />
<title>D3 + Canvas: High-density Line (Downsampling + Interpolation Selector)</title>
<style>
  :root { color-scheme: light dark; }
  body { margin: 0; font: 13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  #wrap { width: 100%; max-width: 1000px; margin: 24px auto; padding: 0 12px; }
  .chart { position: relative; user-select: none; }
  .axis path, .axis line { shape-rendering: crispEdges; }
  .hud { display: flex; gap: 12px; align-items: center; margin-bottom: 8px; flex-wrap: wrap; }
  .hud label { display: inline-flex; gap: 6px; align-items: center; }
  .legend { opacity: .7; }
  input[type="number"] { width: 10ch; }
  button { padding: 4px 10px; }
  .hidden { display: none; }
</style>

<div id="wrap">
  <div class="hud">
    <label><input id="autoY" type="checkbox" checked /> авто-масштаб Y при зуме</label>
    <label><input id="useDS" type="checkbox" checked /> даунсемплинг</label>
    <label class="rate">агрессивность: <input id="dsRate" type="range" min="1" max="16" step="1" value="1" /> <b id="dsRateLabel">1px/бин</b></label>

    <label><input id="useInterp" type="checkbox" /> интерполяция</label>
    <label>тип:
      <select id="curveSelect" disabled>
        <option value="catmullRom">Catmull–Rom</option>
        <option value="monotoneX">Monotone X</option>
        <option value="natural">Natural</option>
        <option value="basis">Basis</option>
        <option value="cardinal">Cardinal</option>
        <option value="bundle">Bundle</option>
        <option value="bumpX">Bump X</option>
        <option value="step">Step</option>
        <option value="stepBefore">Step Before</option>
        <option value="stepAfter">Step After</option>
        <option value="linear">Linear</option>
      </select>
    </label>

    <label id="alphaWrap" class="hidden">α: <input id="alphaSlider" type="range" min="0" max="1" step="0.05" value="0.5" /> <b id="alphaLabel">0.50</b></label>
    <label id="tensionWrap" class="hidden">τ: <input id="tensionSlider" type="range" min="0" max="1" step="0.05" value="0.00" /> <b id="tensionLabel">0.00</b></label>
    <label id="betaWrap" class="hidden">β: <input id="betaSlider" type="range" min="0" max="1" step="0.05" value="0.85" /> <b id="betaLabel">0.85</b></label>

    <label>точек: <input id="nInput" type="number" min="1000" max="5000000" step="10000" value="500000" /></label>
    <button id="regen">Перегенерировать</button>
    <span class="legend">кол-во точек: <b id="count">—</b> · отображается: <b id="visible">—</b></span>
  </div>
  <div id="chart" class="chart"></div>
</div>

<script type="module">
  import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

  // ==== Конфиг ====
  const SIZE = { width: 960, height: 420 };
  const MARGIN = { top: 16, right: 20, bottom: 28, left: 48 };
  const AUTO_RESCALE_Y = true;
  const DEFAULT_USE_DS = true;
  const DEFAULT_USE_INTERP = false;
  const DEFAULT_CURVE = 'catmullRom';
  const LINE_WIDTH = 1;
  const LINE_COLOR = "#2474ff";
  const BG_COLOR = getComputedStyle(document.body).backgroundColor || "#fff";
  const MAX_POINTS = 5_000_000;

  // ==== Базовая сцена ====
  const dpi = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const width = SIZE.width;
  const height = SIZE.height;

  const chart = d3.select("#chart")
    .style("width", `${width}px`)
    .style("height", `${height}px`);

  const canvas = chart.append("canvas")
    .attr("width", width * dpi)
    .attr("height", height * dpi)
    .style("width", `${width}px`)
    .style("height", `${height}px`)
    .node();

  const ctx = canvas.getContext("2d", { desynchronized: true }) || canvas.getContext("2d");
  ctx.scale(dpi, dpi);

  const svg = chart.append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("position", "absolute")
    .style("inset", 0);

  // ==== Шкалы ====
  const x = d3.scaleLinear().range([MARGIN.left, width - MARGIN.right]);
  const y = d3.scaleLinear().range([height - MARGIN.bottom, MARGIN.top]);

  const x0 = x.copy();
  const y0 = y.copy();

  // ==== Оси ====
  const gx = svg.append("g").attr("class", "axis x").attr("transform", `translate(0,${height - MARGIN.bottom})`);
  const gy = svg.append("g").attr("class", "axis y").attr("transform", `translate(${MARGIN.left},0)`);

  function drawAxes() {
    gx.call(d3.axisBottom(x).ticks(Math.floor(width / 80)));
    gy.call(d3.axisLeft(y).ticks(Math.floor(height / 50)));
  }

  // ==== Демо-данные (TypedArray для Y; X = индекс) ====
  function generateY(n) {
    const Y = new Float32Array(n);
    let yv = 0;
    for (let i = 0; i < n; i++) {
      yv += Math.sin(i * 0.015) * 0.3 + (Math.random() - 0.5) * 0.2;
      Y[i] = yv;
    }
    return Y;
  }

  function extentFloat32(arr) {
    let mn = +Infinity, mx = -Infinity;
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i];
      if (v < mn) mn = v;
      if (v > mx) mx = v;
    }
    if (mn === mx) {
      const eps = Math.abs(mn || 1) * 1e-6;
      mn -= eps; mx += eps;
    }
    return [mn, mx];
  }

  let Y = new Float32Array(0);
  let N = 0;

  const nInput = document.getElementById("nInput");
  const regenBtn = document.getElementById("regen");
  const countEl = d3.select("#count");
  const visibleEl = d3.select("#visible");

  function clamp(n, min, max) { return Math.min(max, Math.max(min, n)); }

  function setData(n) {
    N = clamp(parseInt(n, 10) || 0, +nInput.min, MAX_POINTS);
    nInput.value = String(N);

    Y = generateY(N);
    countEl.text(N.toLocaleString("en-US"));

    // X = [0, N-1]
    x.domain([0, Math.max(1, N - 1)]);
    x0.domain(x.domain());

    // Y — из массива
    y.domain(extentFloat32(Y)).nice();
    y0.domain(y.domain());

    overlay.call(zoom.transform, d3.zoomIdentity);

    drawAxes();
    scheduleRender();
  }

  // ==== Вычисление видимого диапазона индексов ====
  function visibleIndexRange() {
    if (N === 0) return [0, -1];
    const [xStart, xEnd] = x.domain();  // могут быть дробными
    const i0 = clamp(Math.floor(xStart), 0, N - 1);
    const i1 = clamp(Math.ceil(xEnd), 0, N - 1);
    if (i1 < i0) return [i0, i0];
    return [i0, i1];
  }

  // ==== Децимация: min/max на колонку пикселя (TypedArray) ====
  function decimateMinMaxPerPixelY(Y, xScale, binPx = 1, i0 = 0, i1 = Y.length - 1) {
    const leftPx = MARGIN.left;
    const rightPx = width - MARGIN.right;
    const innerWidth = rightPx - leftPx;
    if (innerWidth <= 0) return [];

    const [xStart, xEnd] = xScale.domain();
    const domainSpan = xEnd - xStart || 1;

    const binsCount = Math.max(1, Math.floor(innerWidth / Math.max(1, binPx)));
    const binsMin = new Array(binsCount);
    const binsMax = new Array(binsCount);

    // Ограничиваемся видимым диапазоном индексов
    for (let i = i0; i <= i1; i++) {
      const vx = i; // X == индекс
      if (vx < xStart || vx > xEnd) continue;

      const pos = (vx - xStart) / domainSpan * (innerWidth - 1);
      const b = Math.min(binsCount - 1, Math.max(0, Math.floor(pos / Math.max(1, binPx))));
      const vy = Y[i];

      const bmin = binsMin[b];
      if (!bmin || vy < bmin.vy) binsMin[b] = { i, vy };

      const bmax = binsMax[b];
      if (!bmax || vy > bmax.vy) binsMax[b] = { i, vy };
    }

    // Сбор индексов в порядке возрастания i (важно!)
    const idx = [];
    for (let b = 0; b < binsCount; b++) {
      const mn = binsMin[b];
      const mx = binsMax[b];
      if (!mn && !mx) continue;
      if (!mn || !mx || mn.i === mx.i) {
        const ii = (mn || mx).i;
        if (idx.length === 0 || idx[idx.length - 1] !== ii) idx.push(ii);
      } else {
        if (mn.i < mx.i) {
          if (idx.length === 0 || idx[idx.length - 1] !== mn.i) idx.push(mn.i);
          if (idx[idx.length - 1] !== mx.i) idx.push(mx.i);
        } else {
          if (idx.length === 0 || idx[idx.length - 1] !== mx.i) idx.push(mx.i);
          if (idx[idx.length - 1] !== mn.i) idx.push(mn.i);
        }
      }
    }

    // Пришиваем крайние индексы окна
    if (i0 <= i1) {
      if (idx.length === 0 || idx[0] !== i0) idx.unshift(i0);
      if (idx[idx.length - 1] !== i1) idx.push(i1);
    }

    // Формируем точки для d3.line
    const points = new Array(idx.length);
    for (let k = 0; k < idx.length; k++) {
      const ii = idx[k];
      points[k] = { x: ii, y: Y[ii] };
    }
    return points;
  }

  // ==== Линия через d3-shape с Canvas контекстом ====
  const lineGen = d3.line()
    .defined(d => Number.isFinite(d.y))
    .x(d => x(d.x))
    .y(d => y(d.y))
    .context(ctx);

  function clearCanvas() {
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (BG_COLOR) {
      ctx.fillStyle = BG_COLOR;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    ctx.restore();
  }

  function drawLine(points) {
    if (!points.length) return;
    ctx.save();
    // Клип по области графика
    ctx.beginPath();
    ctx.rect(MARGIN.left, MARGIN.top, width - MARGIN.left - MARGIN.right, height - MARGIN.top - MARGIN.bottom);
    ctx.clip();

    ctx.beginPath();
    lineGen(points);
    ctx.lineWidth = LINE_WIDTH;
    ctx.strokeStyle = LINE_COLOR;
    ctx.stroke();
    ctx.restore();
  }

  function computeVisibleYDomainFromPoints(points) {
    if (!points.length) return y.domain();
    let ymin = +Infinity, ymax = -Infinity;
    for (let i = 0; i < points.length; i++) {
      const v = points[i].y;
      if (v < ymin) ymin = v;
      if (v > ymax) ymax = v;
    }
    if (ymin === ymax) {
      const eps = Math.abs(ymin || 1) * 1e-6;
      ymin -= eps; ymax += eps;
    }
    return [ymin, ymax];
  }

  // RAF-батчинг
  let raf = 0;
  function scheduleRender() {
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(render);
  }

  // ==== UI элементы ====
  const autoY = document.getElementById("autoY");
  autoY.checked = AUTO_RESCALE_Y;
  autoY.addEventListener("change", scheduleRender);

  const useDS = document.getElementById("useDS");
  useDS.checked = DEFAULT_USE_DS;

  const dsRate = document.getElementById("dsRate");
  const dsRateLabel = document.getElementById("dsRateLabel");
  function updateRateLabel() { dsRateLabel.textContent = `${dsRate.value}px/бин`; }
  updateRateLabel();

  useDS.addEventListener("change", () => {
    dsRate.disabled = !useDS.checked;
    scheduleRender();
  });
  dsRate.addEventListener("input", () => { updateRateLabel(); scheduleRender(); });
  dsRate.disabled = !useDS.checked;

  const useInterp = document.getElementById("useInterp");
  useInterp.checked = DEFAULT_USE_INTERP;

  const curveSelect = document.getElementById("curveSelect");
  curveSelect.value = DEFAULT_CURVE;

  const alphaWrap = document.getElementById("alphaWrap");
  const tensionWrap = document.getElementById("tensionWrap");
  const betaWrap = document.getElementById("betaWrap");

  const alphaSlider = document.getElementById("alphaSlider");
  const alphaLabel = document.getElementById("alphaLabel");
  const tensionSlider = document.getElementById("tensionSlider");
  const tensionLabel = document.getElementById("tensionLabel");
  const betaSlider = document.getElementById("betaSlider");
  const betaLabel = document.getElementById("betaLabel");

  function fmt2(v) { return (+v).toFixed(2); }

  function updateInterpControlsState() {
    const enabled = useInterp.checked;
    curveSelect.disabled = !enabled;
    const sel = curveSelect.value;
    alphaWrap.classList.toggle('hidden', !(enabled && sel === 'catmullRom'));
    tensionWrap.classList.toggle('hidden', !(enabled && sel === 'cardinal'));
    betaWrap.classList.toggle('hidden', !(enabled && sel === 'bundle'));
  }

  function updateParamLabels() {
    alphaLabel.textContent = fmt2(alphaSlider.value);
    tensionLabel.textContent = fmt2(tensionSlider.value);
    betaLabel.textContent = fmt2(betaSlider.value);
  }

  function getSelectedCurve() {
    const sel = curveSelect.value;
    switch (sel) {
      case 'catmullRom': return d3.curveCatmullRom.alpha(parseFloat(alphaSlider.value) || 0.5);
      case 'cardinal':  return d3.curveCardinal.tension(parseFloat(tensionSlider.value) || 0);
      case 'bundle':    return d3.curveBundle.beta(parseFloat(betaSlider.value) || 0.85);
      case 'monotoneX': return d3.curveMonotoneX;
      case 'natural':   return d3.curveNatural;
      case 'basis':     return d3.curveBasis;
      case 'bumpX':     return d3.curveBumpX;
      case 'step':      return d3.curveStep;
      case 'stepBefore':return d3.curveStepBefore;
      case 'stepAfter': return d3.curveStepAfter;
      case 'linear':
      default:          return d3.curveLinear;
    }
  }

  function applyCurve() {
    if (useInterp.checked) {
      lineGen.curve(getSelectedCurve());
    } else {
      lineGen.curve(d3.curveLinear);
    }
  }

  updateParamLabels();
  updateInterpControlsState();
  applyCurve();

  useInterp.addEventListener('change', () => { updateInterpControlsState(); applyCurve(); scheduleRender(); });
  curveSelect.addEventListener('change', () => { updateInterpControlsState(); applyCurve(); scheduleRender(); });
  alphaSlider.addEventListener('input', () => { updateParamLabels(); applyCurve(); scheduleRender(); });
  tensionSlider.addEventListener('input', () => { updateParamLabels(); applyCurve(); scheduleRender(); });
  betaSlider.addEventListener('input', () => { updateParamLabels(); applyCurve(); scheduleRender(); });

  // ==== Рендер ====
  function render() {
    clearCanvas();

    let points = [];
    const [i0, i1] = visibleIndexRange();

    if (useDS.checked) {
      points = decimateMinMaxPerPixelY(
        Y,
        x,
        Math.max(1, parseInt(dsRate.value, 10) || 1),
        i0,
        i1
      );
    } else {
      // Оптимизированный проход по диапазону индексов (без filter)
      const len = Math.max(0, i1 - i0 + 1);
      points = new Array(len);
      for (let i = 0; i < len; i++) {
        const ii = i0 + i;
        points[i] = { x: ii, y: Y[ii] };
      }
    }

    if (autoY.checked) {
      y.domain(computeVisibleYDomainFromPoints(points)).nice();
    } else {
      y.domain(y0.domain());
    }

    drawAxes();
    visibleEl.text(points.length.toLocaleString("en-US"));
    drawLine(points);
  }

  // ==== Зум/пан ====
  const zoom = d3.zoom()
    .scaleExtent([1, 10_000])
    .translateExtent([[MARGIN.left, MARGIN.top], [width - MARGIN.right, height - MARGIN.bottom]])
    .on("zoom", (ev) => {
      const t = ev.transform;
      const zx = t.rescaleX(x0);
      x.domain(zx.domain());
      scheduleRender();
    });

  const overlay = svg.append("rect")
    .attr("x", MARGIN.left)
    .attr("y", MARGIN.top)
    .attr("width", width - MARGIN.left - MARGIN.right)
    .attr("height", height - MARGIN.top - MARGIN.bottom)
    .style("fill", "transparent")
    .style("cursor", "grab")
    .call(zoom);

  // ==== Инициализация ====
  setData(nInput.value);
  regenBtn.addEventListener("click", () => setData(nInput.value));
  nInput.addEventListener("keydown", (e) => { if (e.key === "Enter") setData(nInput.value); });

  drawAxes();
  render();
</script>
